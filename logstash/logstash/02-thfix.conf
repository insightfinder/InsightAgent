filter {
  if [fields][application] == "thfix" {
    grok {
      match => {
        'message' => [
          '^(?<ts>\d{8}-\d{2}:\d{2}:\d{2}\.\d{3}) \[(?<log_level>\w+)\] \[(?<thread_id>\d+)\]\s*%{GREEDYDATA:log_data}'
        ]
      }
    }

    if "_grokparsefailure" in [tags] { drop { } }

    grok {
      match => {
        'log_data' => [
          '\[(?<direction>(IN|OUT))\].*11=(?<ciordid>\S*)'
        ]
      }
      add_tag => [ "fix_data" ]
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir2>(IN|OUT))\].*56=(?<targetID>\S*)'
        ]
      }
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*52=(?<req_ts>\S*)'
        ]
      }
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*35=(?<msgType>\S*)'
        ]
      }
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*38=(?<orderQty>\S*)'
        ]
      }
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir1>(IN|OUT))\].*49=(?<senderID>\S*)'
        ]
      }
    }

    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*60=(?<transc_time>\S*)'
        ]
      }
    }
    #----------------------------NEW CODE --------------------------------
    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*17=(?<execID>\S*)'
        ]
      }
    }
    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*37=(?<orderID>\S*)'
        ]
      }
    }
    grok {
      match => {
        'log_data' => [
          '\[(?<dir>(IN|OUT))\].*66=(?<field_66>\S*)'
        ]
      }
    }
    #----------------------------NEW CODE END --------------------------------

    date {
      match => [ "req_ts", "yyyyMMdd-HH:mm:ss.SSS", "yyyyMMdd-HH:mm:ss" ]
    #   timezone => "%{[event][timezone]}"
      target => "req_ts_event"
    }

    date {
      match => [ "transc_time", "yyyyMMdd-HH:mm:ss.SSS", "yyyyMMdd-HH:mm:ss" ]
    #   timezone => "%{[event][timezone]}"
      target => "transaction_time"
    }

    date {
      match => [ "ts", "yyyyMMdd-HH:mm:ss.SSS" ]
    #   timezone => "%{[event][timezone]}"
      target => "ts_event"
    }

    mutate {
      gsub => ["message", "\u0001", " "]
    }

    if "fix_data" in [tags] {
      if [direction] == "IN" {
        aggregate {
          task_id => "%{ciordid}%{execID}%{orderID}%{field_66}%{msgType}%{orderQty}%{senderSubID}%{senderID}%{transaction_time}"
          code => "
            map['in'] ||= Set.new; map['in'] << event.get('ts_event')
          "
          timeout => 60
        }
        aggregate {
          task_id => "%{ciordid}%{execID}%{orderID}%{field_66}%{msgType}%{orderQty}%{senderSubID}%{targetID}%{transaction_time}"
          code => "
            map['in'] ||= Set.new; map['in'] << event.get('ts_event')
          "
          timeout => 60
        }
        ruby {
          code => "
            time_diff = (event.get('ts_event') - event.get('req_ts_event')) * 1000
            time_mod = time_diff % 1800000
            if time_mod  < 900000 # this is the positive time diff
              if (event.get('req_ts').to_s =~ /^\d{8}-\d{2}:\d{2}:\d{2}\.\d{3}$/)
                # with millisecond
                if time_mod < 60000
                  event.set('[data][receiving_delay]', time_mod)
                else
                  #above 60000, drop
                  event.set('[data][receiving_delay]', 'drop')
                end
              else
                # without millisecond
                if time_mod > 2000 && time_mod < 60000
                  #bigger than 2000 mark 1000
                  event.set('[data][receiving_delay]', 1000)
                else
                  # otherwise, mark DROP
                  event.set('[data][receiving_delay]', 'drop')
                end
              end
            else
              # mark negative as NA
              event.set('[data][receiving_delay]', 'NA')
            end
          "
        }
        mutate {
          add_field => {
            "instance_name" => "%{[host][hostname]}-%{senderID}-receiving"
            "project_name" => "thfix-transaction-logs"
          }
        }
      } else if [direction] == "OUT" {
        aggregate {
          task_id => "%{ciordid}%{execID}%{orderID}%{field_66}%{msgType}%{orderQty}%{senderSubID}%{senderID}%{transaction_time}"
          code => "
            array = map['in'].to_a
            sorted_array = array.sort{|a,b| b<=>a}
            result = nil
            element = sorted_array.pop
            event.set('[data][in_msg_ts]', element)
            map['in'] = sorted_array.to_set
            if !element.nil? && (element <= event.get('ts_event'))
              result = element
            else
              # no IN element or IN ts is larger than OUT, mark NA
              event.set('[data][processing_time]', 'NA' )
            end

            if !result.nil?
              time_gap = (event.get('ts_event') - result) * 1000
              if time_gap < 60000
                event.set('[data][processing_time]', time_gap )
              else
                event.set('[data][processing_time]', 'DROP' )
              end
            end
          "
          map_action => "update"
        }
        aggregate {
          task_id => "%{ciordid}%{execID}%{orderID}%{field_66}%{msgType}%{orderQty}%{senderSubID}%{targetID}%{transaction_time}"
          code => "
            array = map['in'].to_a
            sorted_array = array.sort{|a,b| b<=>a}
            result = nil
            element = sorted_array.pop
            event.set('[data][in_msg_ts]', element)
            map['in'] = sorted_array.to_set
            if !element.nil? && (element <= event.get('ts_event'))
              result = element
            else
              # no IN element or IN ts is larger than OUT, mark NA
              event.set('[data][processing_time]', 'NA' )
            end

            if !result.nil?
              time_gap = (event.get('ts_event') - result) * 1000
              if time_gap < 60000
                event.set('[data][processing_time]', time_gap )
              else
                event.set('[data][processing_time]', 'DROP' )
              end
            end
          "
          map_action => "update"
        }
        
        ruby {
            code => "
            time_diff = (event.get('ts_event') - event.get('req_ts_event')) * 1000
            time_mod = time_diff % 1800000
            # handle negative
            if time_mod  < 900000
              if (event.get('req_ts').to_s =~ /^\d{8}-\d{2}:\d{2}:\d{2}\.\d{3}$/)
                # with millisecond
                if time_mod < 60000
                  event.set('[data][sending_delay]', time_mod)
                else
                  #above 60000, drop
                  event.set('[data][sending_delay]', 'drop')
                end
              else
                # without millisecond
                if time_mod > 2000 && time_mod < 60000
                  #bigger than 2000 mark 1000
                  event.set('[data][sending_delay]', 1000)
                else
                  # otherwise, mark DROP
                  event.set('[data][sending_delay]', 'drop')
                end
              end
            else
              # mark negative as NA
              event.set('[data][sending_delay]', 'NA')
            end

            # No Match, MARK NA
            if event.get('[data][processing_time]').nil?
              event.set('[data][processing_time]', 'unmatched taskId')
            end
            "
        }
        mutate {
          add_field => {
            "instance_name" => "%{[host][hostname]}-%{targetID}-processing"
            "project_name" => "thfix-transaction-logs"
          }
        }
      }
    } else {
      mutate {
        add_field => {
          "instance_name" => "%{[host][hostname]}"
          "project_name" => "thfix-application-logs"
        }
      }
    }

    mutate {
      add_field => {
        "[data][message]" => "%{message}"
        "[data][log_file]" => "%{[log][file][path]}"
      }
    }

    mutate {
      add_field => {
        "agent_type" => "LogStreaming"
        "user_name" => "user"
        "license_key" => "a333bd39662ad1edf64e99e97e4b776109827234"
      }
    }
  }
}